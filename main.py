"""
Суть игры: два лагеря цифр воюют друг с другом.
Боевые действия - это операции +, -, *, /. Пока хватит.
Один лагерь ничего не знает о боевом потенциале другого лагеря.
(Это обеспечивается воздействием инструментов модуля random на оба лагеря).

Но эти лагери - непримиримые враги (положительные и отрицательные числа).

По итогам войн определяются количества предательств(пока что не реализовал) и потерь
(цифра-воин поменяла знак или
обнулилось).

Это простенький тестовый вариант.

ПОСЛЕ ДОЛГИХ ТЕСТОВ я понял одно: правила нужно дополнять. Ибо ни разу не произошло обнуление хотя бы одного лагеря.
(Хотя может я просто ошибся в перехвате таких  событий if-ами... Надо присвоить 0 кому-нибудь вручную и проверить эти "условки".)
Зато целых 2 раза (из ~30 тестов) произошло  предательство солдат. (Но почему-то одновременно в обоих лагерях. Странно...)

Идеи после тестов:
    -добавить редкое событие для бойцов. Ну, типа если цифры-бойцы, к примеру, палиндромы (хотя бы одно из них),
    то выполнить с ними что-нибудь заебатое...или пиздатое. Я ещё не придумал. А если серьёзно, то, нуу, к примеру...
    "предсмертное состояние" для обоих лагерей - снизить их состояния до 1 или что-то около того.
    - добавить особые "боевые действия" - возведение в степень и тому подобное. Тоже при условии какого-то события

МЫСЛИ:
    -Я думаю, что у меня получилась прикольная саморегулируемая симуляция "боевых действий" между "цифровыми бойцами".
    И всё это на основе великого рандома и свойств чисел и операций с ними!:)
    ЧТОБЫ ИГРА СТАЛА ИНТЕРЕСНОЙ, НУЖНА  Ф А Н Т А З И Я  или графический интерфейс + фантазия.

    И, конечно же, отмечу главное: если игру попробуют люди без ЛЮБВИ к математике и цифрам, то они сразу посчитают игру
    ПОЛНОЙ ХУИТОЙ :D

Скрытая проблема:
    - my_randomizer() без инпутов будет возвращать в X и Y одинаковые значения.
    РЕШЕНИЕ:
    Добавить слой "рандомности". Например, выбирать случайное число между 2,3 или 4 и на него классически делить второе число,
    возвращённое ф-ей my_randomizer(). То есть сделать Y более случайным, но всегда меньшим, чем X. В оющем, можно заморочить ещё больше.
    К примеру, в случайном порядке присваивать результаты: то сперва для переменной X, при другом запуске - наоборот. Это уравняет шансы "бойцов"
"""

import random, time

camp1 = [2]; camp2 = [-2]

# для случайного числа для второго аргумента для random.randrange(start, stop, [step])
def my_randomizer():
    """отсеивает, выбирает и возвращает последнюю секунду текущего времени"""
    while True: # остановится, когда будет что-то кроме 00 секунд
        l_time = time.asctime().split()
        l_time = l_time[3].split(':')
        if int(l_time[2]) > 1:
            break
    return int(l_time[2])

def my_micro_randomizer(x,y):
    my_list = [x,y]
    x_, y_ = 0, 0
    i = random.randrange(0,2)
    x_ = my_list[i]
    i = random.randrange(0,2)
    y_ = my_list[i]

    return x_,y_

# preparing to battle

x = my_randomizer()
y = my_randomizer()
x,y = my_micro_randomizer(x,y)

print('for test: x == %s' % x)
input('Type any key to proceed...')
for w in camp1:
    w = w * random.randrange(start=1, stop=x)
    camp1[0] = w

print('for test: y == %s' % y)
input('Type any key to proceed...')
for w in camp2:
    w = w * random.randrange(start=1, stop=y)
    camp2[0] = w

# Битва чисел до тех пор пока хотя бы один не сдохнет (обнулится)
# now wariors ready! Let's get rumble!
print('War is begin...')
print('...And it will end when someone or both will death!...')
print('Wait for results...')
print('TEST MODE: only 10 iterations for war!')
print('TEST MODE: begin states: %s and %s' % (camp1[0], camp2[0]))

count = 0 # for tracing state of war

while True:
    # закончить войну в случае смерти хотя бы одно из бойцов
    if not camp1[0] or not camp2[0]:
        print('Battle is end! Someone death!')
        print("Let's see who's death...")
        print('Camp One ->', camp1[0], 'Camp Two ->', camp2[0])
        if camp1[0] != camp2[0]:
            l_digs = camp1 + camp2
            l_digs.sort()
            my_winner = [w for w in globals().keys() if 'camp' in w and eval(w)[0]] # очен сложный, моя еле додумался
            print('The Winner is...',  my_winner[0], '!')
            break
        else:
            print('All death!!!')

    count += 1 # instead of ++
    
    camp1[0] = camp1[0] + camp2[0]
    camp2[0] = camp2[0] + camp1[0]
    camp1[0] = camp1[0] - camp2[0]
    camp2[0] = camp2[0] - camp1[0]
    # временно исключить эти операции (тестовый режим)
    """
    camp1[0] = camp1[0] * camp2[0]
    camp2[0] = camp2[0] * camp1[0]
    if camp2[0]:
        camp1[0] = camp1[0] / camp2[0]
    if camp1[0]:
        camp2[0] = camp2[0] / camp1[0]"""

    # держать бойцов в рамках разумного (если один или оба стали "мощнее" 1000, то поделить обо напополам)
    # пометка: разделить на 2 не обязательно значит загнать число в диапазон "до 1000"
    if (camp1[0] > 1000) or (camp2[0] > 1000):
        camp1[0] //= 2
        camp2[0] //= 2
        print('...Both wariors divizioned by 2...')

    if count == 10:
        print('End of war... Current states of camps -> camp1 %s and camp2 %s' % (camp1[0], camp2[0]))
        count = 0
        break

input('\nkonets testa, S6IHOK Y06AH6IY !')
